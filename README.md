      **写出优秀的代码，是我所追求的。**
第二章：创建和销毁对象

	`1.产生对象时，切忌第一反应就是提供公有构造器,考虑使用静态工厂方法。`
	2.重叠构造器模式，就是当属性比较多时，提供多个构造器，构造器参数依次增加。但是可读性比较差
	3.构建器模式：四个参数以上时，建议使用构建器模式
	4.比如一些工具类，我们并不想将这些类进行实例化，所以可以将这个类的无参构造器设置为private的，让外界访问不到，但是可以通过反射的方式进行强行访问。
	5.避免创建不必要的对象：如 String str = new String("hello");会创建两个对象，直接使用String str = "hello";就好了。 
	6.java支持自动装箱，拆箱。使用时要慎重，避免不必要的自动装箱拆箱。如int与Integer之间的使用就要注意，避免频繁的进行转换。
	7.消除过期的对象引用：java对于没用的对象会进行垃圾回收，但并不是说就不用考虑内存的事情了。
	8.如果是由类自己来管理内存，那么就应该小心了。一旦元素被释放掉，那么就应该讲元素的引用置为null;用完了之后不在用的对象一律置为null。
	9.避免使用终结方法finalizer来进行垃圾回收，因为java语言规范不仅不会保证终结方法会被及时的执行，而是不保证会被执行。
	    System.gc()和System.runFinalization()虽然增加了终结方法执行的机会，但是也不会保证一定会执行;
第三章：对于所有对象都通用的方法

        equals(),hashCode(),comparable()方法。；
    1.equals()方法要满足一致性，自反性，传递性
    2.hashCode()：覆盖equals就要覆盖hashCode()方法
    3.所有的子类都应该覆盖toString()方法。
    4.Cloneable接口是没有方法的。所有实现了Cloneable的方法都应该覆盖Object的clone方法。此方法会首先调用super.clone()，然后修正任何需要修正的域。
        不可变的类是不支持拷贝的。clone这里有点不大懂,一般情况下也不会用clone。缺点太多。
    5.Comparable接口：如果一个类，实现了Comparable接口，说明这个类实例具有内在的排序性质。
第四章：类和接口

    1.第一规则：尽可能的使每个类或成员不被外界访问。实例域不能是公有的。公有类永远都不应该暴露可变的域。
        final修饰的可变对象的引用：虽然引用本省不能被修改，但是它所引用的对象却可以被修改。
        设计： 公有类不应该含有公有域，除了静态公有域，但是静态公有域也应该确保修饰的引用是不可变对象。
    2.final修饰的类，这个类是不能被拓展（继承）的。为了防止粗心或者恶意的子类假装对象的状态已经改变，从而破坏类的不可变行为。
        final修饰的变量不会默认初始化。
    3.如何使类变成不可变的类：
        1.为了确保不可变性，类绝对不允许被子类化，需要用final修饰类。并用final修饰成员变量
        2.将类的所有的构造器都变成私有的，并用静态工厂方法来代替共有的构造器。并用final修饰成员变量
    4.许多不可变的类具有一个或多个非final的域，再第一次访问时，可以将结果缓存在域中，这种情况可以很好的工作，因为对象是不可变的，它的不可变性如果这些计算如果被再次执行，就会产生相同的结果。延迟初始化，String类就用到了。
    5.坚决不要为每个get方法编写一个相应的set方法。除非有很好的理由要让类变成可变的类，否则就应该是不可变的。
        如果类不能被做成不可变的，仍然应该限制它的可变性。降低对象可一存在的状态数。即使域成为final的。除非有令人信服的理由使域变成非final的。
    6.复合优于继承
       注意： 如果父类的构造函数中调用的方法被子类重写，那么调用的会是子类的方法。所以父类的构造器内最好不要调用子类重写的父类的方法。
    7.接口要优于抽象类 —————— 骨架类实现，是为了继承的目的而设计的。
    8.接口应该只用于来定义类型，不应该用来导出常量。
    9.用函数对象表示策略
    10.嵌套类有四种：
        1.静态成员类
        2.非静态成员类
        3.匿名类
        4.局部类
        除了静态成员类，替他三种统称为内部类。
        静态成员类和非静态成员类的区别：
            在没有外围类的实例的情况下，要想创建非静态成员类的实例是不可能的。
    11.如果声明成员类不要求访问外围实例，就要始终把statis修饰符放在它的声明中。如果省略了static修饰符，则每个实例都将额外的指向一个外围对象的引用，
        保存这个引用需要消耗时间和空间，并且不会被垃圾回收。
    12.有时候并不用写一个接口的实现，直接通过匿名内部类的方式来实现可能会更加方便。
第五章：泛型

    1.请不要使用原生态类型，要使用泛型，使用List这样的原生态类型，会失掉类型安全性，但是使用List<Object>这样的参数化类型就不会。
        List<String>可以传递个类型List的参数，但不能传递给List<Object>的参数。
        无限制通配符类型? 如list<?>,
        所以：List<Object>是个参数化类型，表示可以包含任何对象类型的一个集合，List<?>则是一个通配符类型，表示只能包含某种未知对象类型的一个集合。而List是原生类型，不建议使用。
    2.要坚持住，要尽可能的消除每一个非受检警告。@SuppressWarnning注解：应该在尽可能小的范围内使用该注解，永远不要在整个类上使用该注解，
        非受检警告很重要，要尽可能想办法消除，如果实在消除不了，就使用@SuppressWarnning注解，同时把禁止该警告的原因写下来。